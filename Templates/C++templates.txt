第一章---第三章：

对于非模板函数和同名的函数模板，如果其它条件都是相同的，那么在调用过程，重载解析过程通常会调用非模板函数。模板是允许自动类型转化。

模板的重载实现里面，例子中是通过传递引用来实现的，重载函数模板最好改变那些需要改变的内容，限制在：改变参数的数目或显示的指定模板参数，否则可能出现非预期的方式，注意在三个模板调用两个参数的模板的时候，参数类型的匹配。值引用和自己写的模板，比如返回临时变量，就会有错误。 模板的嵌套调用注意可见性，模板声明在一定在使用之前。


类的类型要加上Stack<T>,类名，类的解析和构造函数，Stack


类模板成员函数，使用这个类模板的完整类型限定符。void Stack<T>::push(T const& elem);


对于类模板，成员函数只有在被使用的时候才会被实例化。


节省空间和时间，还有一个好处，比如有些未能提供operator<类型的，不调用这些成员函数，也可以被用来实例化该类模板。


如果类模板中有静态成员，那么用来实例化的每种类型，都会实例化这些静态成员。


当有两个靠在一起的模板尖括号>之间要留一个空格，否则编译器将会认为你在使用operator>>，这将导致一个语法错误。


模板的特化，初始位置声明一个template<>，接下来声明特化类模板的类型，必须在类名后面直接指定。


template<> class Stack<std::string>{}


类模板特化时，每个成员函数都必须要重新定义为普通函数，原来的每个T被特化类型取代


！！！特化的实现可以和基本类模板的实现完全不同


局部特化：类模板可以被局部特化，可以在特定的环境下指定类模板的特定实现。


template<typename T1,typename T2> class Myclass{}    template<typename T> class Myclass<T,T>{ ... }  template<typename T> class Myclass<T,int> {....} t template<typename T1,typename T2> class Myclass<T1*,T2*>{....}


如果特化同程度的匹配某个声明，声明具有二义性



第四章：非类型模板参数